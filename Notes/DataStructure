Linked List
1. Linked List Insertion.
2. Linked List Deletion.
3. To count a number of times a given integer occured in a node.
4. Reverse a linked list.
5. Detect a loop in linked list
6. Middle of a given linked list
7. To check if the singly linked list is a palindrome or not.
8.  



########################################################
01. Introduction to Data Structures
########################################################
--> A data structure is a way to store and organize data in a computer,	so 
that it can be used efficiently.

When we talk about data structures as 
--> Mathematical/Logical model or abstract data type
--> Implementation

Abstract data types
--> Defines data and operations but no implementation
Eg : Arrays, Linked Lists, Stacks, Queues, Trees, Graphs.

########################################################
02. Data Structure List as Abstract Data Types
########################################################




########################################################
03. Introduction to linked list
########################################################


########################################################
04 Data Structures Arrays vs Linked Lists
########################################################



########################################################
05 Linked List - Implementation in C-C++  
########################################################



########################################################
06 Linked List in C-C++ - Inserting a node at beginning
########################################################


########################################################
07 Linked List in C-C++ - Insert a node at nth position
########################################################


########################################################
08 Linked List in C-C++ - Delete a node at nth position
########################################################


########################################################
09 Reverse a linked list - Iterative method
########################################################


########################################################
10 Print elements of a linked list in forward and 
reverse order using recursion
########################################################


########################################################
11 Reverse a linked list using recursion
########################################################


########################################################
12 Data structures Introduction to Doubly Linked List
########################################################


########################################################
13 Doubly Linked List - Implementation in C-C++  
########################################################


########################################################
14 Data structures Introduction to stack
########################################################


########################################################
15 Data structures Array implementation of stacks
########################################################


########################################################
16 Data Structures Linked List implementation of stacks
########################################################


########################################################
17 Reverse a string or linked list using stack.
########################################################


########################################################
18 Check for balanced parentheses using stack
########################################################


########################################################
19 Infix, Prefix and Postfix
########################################################


########################################################
20 Evaluation of Prefix and Postfix expressions using stack
########################################################


########################################################
21 Infix to Postfix using stack
########################################################


########################################################
22 Data structures Introduction to Queues
########################################################


########################################################
23 Data structures Array implementation of Queue
########################################################


########################################################
24 Data structures Linked List implementation of Queue
########################################################


########################################################
25 Data structures Introduction to Trees
########################################################


########################################################
26 Data structures Binary Tree
########################################################


########################################################
27 Data structures Binary Search Tree
########################################################


########################################################
28 Binary search tree - Implementation in C-C++
########################################################


########################################################
29 BST implementation -  memory allocation in stack and heap
########################################################



########################################################
30 Find min and max element in a binary search tree
########################################################



########################################################
31 Find height of a binary tree
########################################################



########################################################
32 Binary tree traversal - breadth-first and depth-first strategies
########################################################



########################################################
33 Binary tree Level Order Traversal
########################################################



########################################################
34 Binary tree traversal Preorder, Inorder, Postorder
########################################################



########################################################
35 Check if a binary tree is binary search tree or not
########################################################



########################################################
36 Delete a node from Binary Search Tree
########################################################



########################################################
37 Inorder Successor in a binary search tree
########################################################




########################################################
38 Data structures Introduction to graphs
########################################################



########################################################
39 Data structures Properties of Graphs
########################################################




########################################################
40 Graph Representation part 01 - Edge List
########################################################




########################################################
41 Graph Representation part 02 - Adjacency Matrix
########################################################



########################################################
GeeksforGeeks - Singly Linked List
########################################################

########################################################
GeeksforGeeks - Circular Linked List
########################################################

########################################################
GeeksforGeeks - Doubly Linked List
########################################################

########################################################
GeeksforGeeks - Stack
########################################################

########################################################
GeeksforGeeks - Queue
########################################################

########################################################
GeeksforGeeks - Binary Tree
########################################################
Binary Tree structure :
struct node {
 int data;
 struct node *left;
 struct node *right;
};
-------------------------------------------------------------------
Create a binary tree node :
struct node *newNode(int data) {
 struct node *node = (struct node*) malloc (sizeof(struct node));
 node->data = data;
 node->left = NULL;
 node->right = NULL;
 return node;
}
-------------------------------------------------------------------
1. Depth First Traversals:
(a) Inorder
(b) Preorder
(c) Postorder

-------------------------------------------------------------------
(a) Inorder Traversal:
Algorithm Inorder(tree)
   1. Traverse the left subtree, i.e., call Inorder(left-subtree)
   2. Visit the root.
   3. Traverse the right subtree, i.e., call Inorder(right-subtree)
Code :
 void printInorder(struct node *node) {
  if (node == NULL)
  return;
  
  printInorder(node->left);
  printf("%d \t",node->data);
  printInorder(node->right);
 }
Time Complexity: O(n)
------------------------------------------------------------------- 
(b) Preorder Traversal:
Algorithm Preorder(tree)
   1. Visit the root.
   2. Traverse the left subtree, i.e., call Preorder(left-subtree)
   3. Traverse the right subtree, i.e., call Preorder(right-subtree)
Code :
void printPreorder(struct node *node) {
 if(node == NULL)
 return;
 
 printf("%d \t",node->data);
 printPreorder(node->left);
 printPreorder(node->right);
}
Time Complexity: O(n)
-------------------------------------------------------------------

(c) Postorder Traversal:
Algorithm Postorder(tree)
   1. Traverse the left subtree, i.e., call Postorder(left-subtree)
   2. Traverse the right subtree, i.e., call Postorder(right-subtree)
   3. Visit the root.
Code :
 void printPostorder(struct node *node) {
  if (node == NULL)
   return ;
   
  printPostorder(node->left);
  printPostorder(node->right);
  printf("%d \t",node->data);
 }
Time Complexity: O(n)
-------------------------------------------------------------------

2. Size of Binary Tree
Algorithm:
size(tree)
1. If tree is empty then return 0
2. Else
     (a) Get the size of left subtree recursively  i.e., call 
          size( tree->left-subtree)
     (a) Get the size of right subtree recursively  i.e., call 
          size( tree->right-subtree)
     (c) Calculate size of the tree as following:
            tree_size  =  size(left-subtree) + size(right-
                               subtree) + 1
     (d) Return tree_size
Code :
int size(struct node *node) {
 if (node == NULL)
  return 0;
 else
  return(size(node->left) + 1 + size(node->right));
}
Time Complexity: O(n)
-------------------------------------------------------------------

3. Detemine if two tree are identical
Algorithm:
sameTree(tree1, tree2)
1. If both trees are empty then return 1.
2. Else If both trees are non -empty
     (a) Check data of the root nodes (tree1->data ==  tree2->data)
     (b) Check left subtrees recursively  i.e., call sameTree( 
          tree1->left_subtree, tree2->left_subtree)
     (c) Check right subtrees recursively  i.e., call sameTree( 
          tree1->right_subtree, tree2->right_subtree)
     (d) If a,b and c are true then return 1.
3  Else return 0 (one is empty and other is not)
Code :
/* Given two trees, return true if they are
 structurally identical */
int identicalTrees(struct node* a, struct node* b)
{
    /*1. both empty */
    if (a==NULL && b==NULL)
        return 1;
 
    /* 2. both non-empty -> compare them */
    if (a!=NULL && b!=NULL)
    {
        return
        (
            a->data == b->data &&
            identicalTrees(a->left, b->left) &&
            identicalTrees(a->right, b->right)
        );
    }
    
    /* 3. one empty, one not -> false */
    return 0;
}
Time Complexity : O(m) where m < n. where number of nodes in two trees be m and n
-------------------------------------------------------------------

########################################################
GeeksforGeeks - Binary Search Tree
########################################################

########################################################
GeeksforGeeks - Heap
########################################################

########################################################
GeeksforGeeks - Hashing
########################################################


########################################################
GeeksforGeeks - Graphs
########################################################


########################################################
GeeksforGeeks - Advanced Data Structure
########################################################


########################################################
GeeksforGeeks - Array
########################################################


########################################################
GeeksforGeeks - Matrix
########################################################


########################################################
GeeksforGeeks - Searching and Sorting
########################################################

########################################################
GeeksforGeeks - Greedy Algorithms
########################################################

########################################################
GeeksforGeeks - Dynamic Programming
########################################################

########################################################
GeeksforGeeks - Pattern Searching
########################################################

########################################################
GeeksforGeeks - Other String Algorithms
########################################################

########################################################
GeeksforGeeks - Backtracking
########################################################

########################################################
GeeksforGeeks - Divide and Conquer
########################################################

########################################################
GeeksforGeeks - Geometric Algorithms
########################################################

########################################################
GeeksforGeeks - Mathematical Algorithms
########################################################

########################################################
GeeksforGeeks - Bit Algorithms 
########################################################
1. Find the element that appears once
int getSingle(int arr[], int n)
{
    int ones = 0, twos = 0 ;
 
    int common_bit_mask;
 
    // Let us take the example of {3, 3, 2, 3} to understand this
    for( int i=0; i< n; i++ )
    {
        /* The expression "one & arr[i]" gives the bits that are
           there in both 'ones' and new element from arr[].  We
           add these bits to 'twos' using bitwise OR
 
           Value of 'twos' will be set as 0, 3, 3 and 1 after 1st,
           2nd, 3rd and 4th iterations respectively */
        twos  = twos | (ones & arr[i]);
 
 
        /* XOR the new bits with previous 'ones' to get all bits
           appearing odd number of times
 
           Value of 'ones' will be set as 3, 0, 2 and 3 after 1st,
           2nd, 3rd and 4th iterations respectively */
        ones  = ones ^ arr[i];
 
 
        /* The common bits are those bits which appear third time
           So these bits should not be there in both 'ones' and 'twos'.
           common_bit_mask contains all these bits as 0, so that the bits can 
           be removed from 'ones' and 'twos'   
 
           Value of 'common_bit_mask' will be set as 00, 00, 01 and 10
           after 1st, 2nd, 3rd and 4th iterations respectively */
        common_bit_mask = ~(ones & twos);
 
 
        /* Remove common bits (the bits that appear third time) from 'ones'
             
           Value of 'ones' will be set as 3, 0, 0 and 2 after 1st,
           2nd, 3rd and 4th iterations respectively */
        ones &= common_bit_mask;
 
 
        /* Remove common bits (the bits that appear third time) from 'twos'
 
           Value of 'twos' will be set as 0, 3, 1 and 0 after 1st,
           2nd, 3rd and 4th itearations respectively */
        twos &= common_bit_mask;
 
        // uncomment this code to see intermediate values
        //printf (" %d %d \n", ones, twos);
    }
 
    return ones;
}
Time Complexity: O(n)
Auxiliary Space: O(1)
--------------------------------------------------------
--------------------------------------------------------
--------------------------------------------------------
--------------------------------------------------------
--------------------------------------------------------
--------------------------------------------------------
########################################################
GeeksforGeeks - Graph Algorithms
########################################################

########################################################
GeeksforGeeks - 
########################################################
########################################################
########################################################
########################################################
